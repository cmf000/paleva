Run options: include {:locations=>{"./spec/system/orders/user_sends_order_to_kitchen_spec.rb"=>[59]}}
"<<<<<<<<<<<<<<<<<<<<"
F

Failures:

  1) Usuário finaliza pedido e pedido não pode estar vazio
     Failure/Error: expect(page).not_to have_content 'Não foi possível'
       expected not to find text "Não foi possível" in "ActiveRecord::RecordInvalid in OrdersController#send_to_kitchen\nA validação falhou: Order offerings não pode ficar em branco\nExtracted source (around line #87):\n85 86 87 88 89 90\ndef raise_validation_error\nraise(RecordInvalid.new(self))\nend\ndef perform_validations(options = {})\nExtracted source (around line #54):\n52 53 54 55 56 57\n# will raise an ActiveRecord::RecordInvalid exception instead of returning +false+ if the record is not valid.\ndef save!(**options)\nperform_validations(options) ? super : raise_validation_error\nend\n# Runs all the validations within the specified context. Returns +true+ if\nExtracted source (around line #366):\n364 365 366 367 368 369\ndef save!(**) # :nodoc:\nwith_transaction_returning_status { super }\nend\ndef touch(*, **) # :nodoc:\nExtracted source (around line #418):\n416 417 418 419 420 421\nremember_transaction_record_state\nstatus = yield\nraise ActiveRecord::Rollback unless status\nend\nstatus\nExtracted source (around line #359):\n357 358 359 360 361 362\nraise ActiveRecord::TransactionIsolationError, \"cannot set isolation when joining a transaction\"\nend\nyield current_transaction.user_transaction\nelse\ntransaction_manager.within_new_transaction(isolation: isolation, joinable: joinable, &block)\nend\nExtracted source (around line #414):\n412 413 414 415 416 417\nensure_finalize = !connection.transaction_open?\nconnection.transaction do\nadd_to_transaction(ensure_finalize || has_transactional_callbacks?)\nremember_transaction_record_state\nExtracted source (around line #389):\n387 388 389 390 391 392\nif lease.connection\nbegin\nyield lease.connection\nensure\nlease.sticky = sticky_was if prevent_permanent_checkout && !sticky_was\nend\nExtracted source (around line #296):\n294 295 296 297 298 299\n# unless the +prevent_permanent_checkout+ argument is set to +true+.\ndef with_connection(prevent_permanent_checkout: false, &block)\nconnection_pool.with_connection(prevent_permanent_checkout: prevent_permanent_checkout, &block)\nend\nattr_writer :connection_specification_name\nExtracted source (around line #410):\n408 409 410 411 412 413\n# instance.\ndef with_transaction_returning_status\nself.class.with_connection do |connection|\nstatus = nil\nensure_finalize = !connection.transaction_open?\nExtracted source (around line #366):\n364 365 366 367 368 369\ndef save!(**) # :nodoc:\nwith_transaction_returning_status { super }\nend\ndef touch(*, **) # :nodoc:\nExtracted source (around line #56):\n54 55 56 57 58 59\ndef save!(**) # :nodoc:\nSuppressor.registry[self.class.name] ? true : super\nend\nend\nend\nExtracted source (around line #581):\n579 580 581 582 583 584\nwith_transaction_returning_status do\nassign_attributes(attributes)\nsave!\nend\nend\nExtracted source (around line #418):\n416 417 418 419 420 421\nremember_transaction_record_state\nstatus = yield\nraise ActiveRecord::Rollback unless status\nend\nstatus\nExtracted source (around line #616):\n614 615 616 617 618 619\ntransaction = begin_transaction(isolation: isolation, joinable: joinable)\nbegin\nyield transaction.user_transaction\nrescue Exception => error\nrollback_transaction\nafter_failure_actions(transaction, error)\nExtracted source (around line #23):\n21 22 23 24 25 26\nbegin\nThread.handle_interrupt(EXCEPTION_IMMEDIATE, &block)\nensure\nmon_exit\nend\nExtracted source (around line #23):\n21 22 23 24 25 26\nbegin\nThread.handle_interrupt(EXCEPTION_IMMEDIATE, &block)\nensure\nmon_exit\nend\nExtracted source (around line #19):\n17 18 19 20 21 22\ndef synchronize(&block)\nThread.handle_interrupt(EXCEPTION_NEVER) do\nmon_enter\nbegin\nExtracted source (around line #19):\n17 18 19 20 21 22\ndef synchronize(&block)\nThread.handle_interrupt(EXCEPTION_NEVER) do\nmon_enter\nbegin\nExtracted source (around line #613):\n611 612 613 614 615 616\ndef within_new_transaction(isolation: nil, joinable: true)\n@connection.lock.synchronize do\ntransaction = begin_transaction(isolation: isolation, joinable: joinable)\nbegin\nyield transaction.user_transaction\nExtracted source (around line #361):\n359 360 361 362 363 364\nyield current_transaction.user_transaction\nelse\ntransaction_manager.within_new_transaction(isolation: isolation, joinable: joinable, &block)\nend\nrescue ActiveRecord::Rollback\n# rollbacks are silently swallowed\nExtracted source (around line #414):\n412 413 414 415 416 417\nensure_finalize = !connection.transaction_open?\nconnection.transaction do\nadd_to_transaction(ensure_finalize || has_transactional_callbacks?)\nremember_transaction_record_state\nExtracted source (around line #389):\n387 388 389 390 391 392\nif lease.connection\nbegin\nyield lease.connection\nensure\nlease.sticky = sticky_was if prevent_permanent_checkout && !sticky_was\nend\nExtracted source (around line #296):\n294 295 296 297 298 299\n# unless the +prevent_permanent_checkout+ argument is set to +true+.\ndef with_connection(prevent_permanent_checkout: false, &block)\nconnection_pool.with_connection(prevent_permanent_checkout: prevent_permanent_checkout, &block)\nend\nattr_writer :connection_specification_name\nExtracted source (around line #410):\n408 409 410 411 412 413\n# instance.\ndef with_transaction_returning_status\nself.class.with_connection do |connection|\nstatus = nil\nensure_finalize = !connection.transaction_open?\nExtracted source (around line #579):\n577 578 579 580 581 582\n# The following transaction covers any possible database side-effects of the\n# attributes assignment. For example, setting the IDs of a child collection.\nwith_transaction_returning_status do\nassign_attributes(attributes)\nsave!\nend\nExtracted source (around line #326):\n324 325 326 327 328 329\n# def active!() update!(status: 0) end\nklass.send(:detect_enum_conflict!, name, \"\#{value_method_name}!\")\ndefine_method(\"\#{value_method_name}!\") { update!(name => value) }\nend\nif scopes\nExtracted source (around line #30):\n28 29 30 31 32 33\ndef send_to_kitchen\n@order = Order.find(params[:id])\n@order.pending_kitchen!\nredirect_to root_path, notice: 'Pedido enviado à cozinha'\nend\nExtracted source (around line #8):\n6 7 8 9 10 11\nmodule BasicImplicitRender # :nodoc:\ndef send_action(method, *args)\nret = super\ndefault_render unless performed?\nret\nend\nExtracted source (around line #226):\n224 225 226 227 228 229\n# necessarily the same as the action name.\ndef process_action(...)\nsend_action(...)\nend\n# Actually call the method associated with the action. Override this method if\nExtracted source (around line #193):\n191 192 193 194 195 196\ndef process_action(*) # :nodoc:\nself.formats = request.formats.filter_map(&:ref)\nsuper\nend\ndef _process_variant(options)\nExtracted source (around line #261):\n259 260 261 262 263 264\ndef process_action(...)\nrun_callbacks(:process_action) do\nsuper\nend\nend\nend\nExtracted source (around line #121):\n119 120 121 122 123 124\ncurrent.invoke_before(env)\nif current.final?\nenv.value = !env.halted && (!block_given? || yield)\nelsif current.skip?(env)\n(skipped ||= []) << current\nnext_sequence = next_sequence.nested\nExtracted source (around line #24):\n22 23 24 25 26 27\ndef with_request_id(request_id)\nold_request_id, self.current_request_id = self.current_request_id, request_id\nyield\nensure\nself.current_request_id = old_request_id\nend\nExtracted source (around line #10):\n8 9 10 11 12\nprivate\ndef turbo_tracking_request_id(&block)\nTurbo.with_request_id(request.headers[\"X-Turbo-Request-Id\"], &block)\nend\nend\nExtracted source (around line #130):\n128 129 130 131 132 133\nbegin\ntarget, block, method, *arguments = current.expand_call_template(env, invoke_sequence)\ntarget.send(method, *arguments, &block)\nensure\nnext_sequence = current\nend\nExtracted source (around line #25):\n23 24 25 26 27 28\nprevious_renderer = self.renderer\nself.renderer = renderer\nyield\nensure\nself.renderer = previous_renderer\nend\nExtracted source (around line #71):\n69 70 71 72 73 74\nActiveSupport.on_load(base) do\naround_action do |controller, action|\nActionText::Content.with_renderer(controller, &action)\nend\nend\nend\nExtracted source (around line #130):\n128 129 130 131 132 133\nbegin\ntarget, block, method, *arguments = current.expand_call_template(env, invoke_sequence)\ntarget.send(method, *arguments, &block)\nensure\nnext_sequence = current\nend\nExtracted source (around line #130):\n128 129 130 131 132 133\nbegin\ntarget, block, method, *arguments = current.expand_call_template(env, invoke_sequence)\ntarget.send(method, *arguments, &block)\nensure\nnext_sequence = current\nend\nExtracted source (around line #141):\n139 140 141 142 143 144\nend\ninvoke_sequence.call\nend\nend\nend\nExtracted source (around line #260):\n258 259 260 261 262 263\n# callbacks around the normal behavior.\ndef process_action(...)\nrun_callbacks(:process_action) do\nsuper\nend\nend\nExtracted source (around line #27):\n25 26 27 28 29 30\nprivate\ndef process_action(*)\nsuper\nrescue Exception => exception\nrequest.env[\"action_dispatch.show_detailed_exceptions\"] ||= show_detailed_exceptions?\nrescue_with_handler(exception) || raise\nExtracted source (around line #77):\n75 76 77 78 79 80\nActiveSupport::Notifications.instrument(\"process_action.action_controller\", raw_payload) do |payload|\nresult = super\npayload[:response] = response\npayload[:status] = response.status\nresult\nExtracted source (around line #210):\n208 209 210 211 212 213\ndef instrument(name, payload = {})\nif notifier.listening?(name)\ninstrumenter.instrument(name, payload) { yield payload if block_given? }\nelse\nyield payload if block_given?\nend\nExtracted source (around line #58):\n56 57 58 59 60 61\nhandle.start\nbegin\nyield payload if block_given?\nrescue Exception => e\npayload[:exception] = [e.class.name, e.message]\npayload[:exception_object] = e\nExtracted source (around line #210):\n208 209 210 211 212 213\ndef instrument(name, payload = {})\nif notifier.listening?(name)\ninstrumenter.instrument(name, payload) { yield payload if block_given? }\nelse\nyield payload if block_given?\nend\nExtracted source (around line #76):\n74 75 76 77 78 79\nActiveSupport::Notifications.instrument(\"start_processing.action_controller\", raw_payload)\nActiveSupport::Notifications.instrument(\"process_action.action_controller\", raw_payload) do |payload|\nresult = super\npayload[:response] = response\npayload[:status] = response.status\nExtracted source (around line #259):\n257 258 259 260 261 262\ndef process_action(*)\n_perform_parameter_wrapping if _wrapper_enabled?\nsuper\nend\n# Returns the wrapper key which will be used to store wrapped parameters.\nExtracted source (around line #39):\n37 38 39 40 41 42\n# and it won't be cleaned up by the method below.\nActiveRecord::RuntimeRegistry.reset\nsuper\nend\ndef cleanup_view_runtime\nExtracted source (around line #163):\n161 162 163 164 165 166\n@_response_body = nil\nprocess_action(action_name, ...)\nend\n# Delegates to the class's ::controller_path.\nExtracted source (around line #40):\n38 39 40 41 42 43\ndef process(...) # :nodoc:\nold_config, I18n.config = I18n.config, I18nProxy.new(I18n.config, lookup_context)\nsuper\nensure\nI18n.config = old_config\nend\nExtracted source (around line #252):\n250 251 252 253 254 255\nset_request!(request)\nset_response!(response)\nprocess(name)\nrequest.commit_flash\nto_a\nend\nExtracted source (around line #335):\n333 334 335 336 337 338\nmiddleware_stack.build(name) { |env| new.dispatch(name, req, res) }.call req.env\nelse\nnew.dispatch(name, req, res)\nend\nend\nend\nExtracted source (around line #67):\n65 66 67 68 69 70\ndef dispatch(controller, action, req, res)\ncontroller.dispatch(action, req, res)\nend\nend\nExtracted source (around line #50):\n48 49 50 51 52 53\ncontroller = controller req\nres = controller.make_response! req\ndispatch(controller, params[:action], req, res)\nrescue ActionController::RoutingError\nif @raise_on_name_error\nraise\nExtracted source (around line #53):\n51 52 53 54 55 56\nreq.route_uri_pattern = route.path.spec.to_s\n_, headers, _ = response = route.app.serve(req)\nif \"pass\" == headers[Constants::X_CASCADE]\nreq.script_name = script_name\nExtracted source (around line #133):\n131 132 133 134 135 136\npath_parameters[name.to_sym] = Utils.unescape_uri(val) if val\n}\nyield [match_data, path_parameters, r]\n}\nend\nExtracted source (around line #126):\n124 125 126 127 128 129\nroutes.sort_by!(&:precedence)\nroutes.each { |r|\nmatch_data = r.path.match(path_info)\npath_parameters = {}\nmatch_data.names.each_with_index { |name, i|\nExtracted source (around line #126):\n124 125 126 127 128 129\nroutes.sort_by!(&:precedence)\nroutes.each { |r|\nmatch_data = r.path.match(path_info)\npath_parameters = {}\nmatch_data.names.each_with_index { |name, i|\nExtracted source (around line #34):\n32 33 34 35 36 37\ndef serve(req)\nfind_routes(req) do |match, parameters, route|\nset_params = req.path_parameters\npath_info = req.path_info\nscript_name = req.script_name\nExtracted source (around line #896):\n894 895 896 897 898 899\nreq = make_request(env)\nreq.path_info = Journey::Router::Utils.normalize_path(req.path_info)\n@router.serve(req)\nend\ndef recognize_path(path, environment = {})\nExtracted source (around line #36):\n34 35 36 37 38 39\nresult = catch(:warden) do\nenv['warden'].on_request\n@app.call(env)\nend\nresult ||= {}\nExtracted source (around line #34):\n32 33 34 35 36 37\nenv['warden'] = Proxy.new(env, self)\nresult = catch(:warden) do\nenv['warden'].on_request\n@app.call(env)\nend\nExtracted source (around line #34):\n32 33 34 35 36 37\nenv['warden'] = Proxy.new(env, self)\nresult = catch(:warden) do\nenv['warden'].on_request\n@app.call(env)\nend\nExtracted source (around line #20):\n18 19 20 21 22 23\nbegin\n_, _, body = response = @app.call(env)\nrescue Exception\nenv[RACK_TEMPFILES]&.each(&:close!)\nraise\nExtracted source (around line #29):\n27 28 29 30 31 32\ndef call(env)\nstatus, headers, body = response = @app.call(env)\nif etag_status?(status) && body.respond_to?(:to_ary) && !skip_caching?(headers)\nbody = body.to_ary\nExtracted source (around line #43):\n41 42 43 44 45 46\nresponse\nelse\n@app.call(env)\nend\nend\nExtracted source (around line #15):\n13 14 15 16 17 18\ndef call(env)\n_, _, body = response = @app.call(env)\nif env[REQUEST_METHOD] == HEAD\nresponse[2] = Rack::BodyProxy.new([]) do\nExtracted source (around line #38):\n36 37 38 39 40 41\ndef call(env)\n_, headers, _ = response = @app.call(env)\nreturn response if policy_present?(headers)\nExtracted source (around line #36):\n34 35 36 37 38 39\ndef call(env)\nstatus, headers, _ = response = @app.call(env)\n# Returning CSP headers with a 304 Not Modified is harmful, since nonces in the\n# new CSP headers might not match nonces in the cached HTML.\nExtracted source (around line #272):\n270 271 272 273 274 275\nreq = make_request env\nprepare_session(req)\nstatus, headers, body = app.call(req.env)\nres = Rack::Response::Raw.new status, headers\ncommit_session(req, res)\n[status, headers, body]\nExtracted source (around line #266):\n264 265 266 267 268 269\ndef call(env)\ncontext(env)\nend\ndef context(env, app = @app)\nExtracted source (around line #704):\n702 703 704 705 706 707\ndef call(env)\nrequest = ActionDispatch::Request.new(env)\nresponse = @app.call(env)\nif request.have_cookie_jar?\ncookie_jar = request.cookie_jar\nExtracted source (around line #31):\n29 30 31 32 33 34\nerror = nil\nresult = run_callbacks :call do\n@app.call(env)\nrescue => error\nend\nraise error if error\nExtracted source (around line #101):\n99 100 101 102 103 104\nif callbacks.empty?\nyield if block_given?\nelse\nenv = Filters::Environment.new(self, false, nil)\nExtracted source (around line #30):\n28 29 30 31 32 33\ndef call(env)\nerror = nil\nresult = run_callbacks :call do\n@app.call(env)\nrescue => error\nend\nExtracted source (around line #18):\n16 17 18 19 20 21\ndef call(env)\nrequest = ActionDispatch::Request.new(env)\nreturn @app.call(env) unless actionable_request?(request)\nActiveSupport::ActionableError.dispatch(request.params[:error].to_s.safe_constantize, request.params[:action])\nExtracted source (around line #31):\n29 30 31 32 33 34\ndef call(env)\n_, headers, body = response = @app.call(env)\nif headers[Constants::X_CASCADE] == \"pass\"\nbody.close if body.respond_to?(:close)\nExtracted source (around line #32):\n30 31 32 33 34 35\ndef call(env)\n@app.call(env)\nrescue Exception => exception\nrequest = ActionDispatch::Request.new env\nbacktrace_cleaner = request.get_header(\"action_dispatch.backtrace_cleaner\")\nExtracted source (around line #41):\n39 40 41 42 43 44\nlogger.info { started_request_message(request) }\nstatus, headers, body = response = @app.call(env)\nbody = ::Rack::BodyProxy.new(body) { finish_request_instrumentation(handle, logger_tag_pop_count) }\nif response.frozen?\nExtracted source (around line #29):\n27 28 29 30 31 32\nend\ncall_app(request, env)\nend\nprivate\nExtracted source (around line #96):\n94 95 96 97 98 99\nreq = ActionDispatch::Request.new env\nreq.remote_ip = GetIp.new(req, check_ip, proxies)\n@app.call(req.env)\nend\n# The GetIp class exists as a way to defer processing of the request data into\nExtracted source (around line #33):\n31 32 33 34 35 36\nreq = ActionDispatch::Request.new env\nreq.request_id = make_request_id(req.headers[@header])\n@app.call(env).tap { |_status, headers, _body| headers[@header] = req.request_id }\nend\nprivate\nExtracted source (around line #28):\n26 27 28 29 30 31\nend\n@app.call(env)\nend\ndef method_override(env)\nExtracted source (around line #24):\n22 23 24 25 26 27\ndef call(env)\nstart_time = Utils.clock_time\n_, headers, _ = response = @app.call(env)\nrequest_time = Utils.clock_time - start_time\nExtracted source (around line #29):\n27 28 29 30 31 32\ndef call(env)\nLocalCacheRegistry.set_cache_for(local_cache_key, LocalStore.new)\nresponse = @app.call(env)\nresponse[2] = ::Rack::BodyProxy.new(response[2]) do\nLocalCacheRegistry.set_cache_for(local_cache_key, nil)\nend\nExtracted source (around line #16):\n14 15 16 17 18 19\nstate = @executor.run!(reset: true)\nbegin\nresponse = @app.call(env)\nif env[\"action_dispatch.report_exception\"]\nerror = env[\"action_dispatch.exception\"]\nExtracted source (around line #27):\n25 26 27 28 29 30\ndef call(env)\n@file_handler.attempt(env) || @app.call(env)\nend\nend\nExtracted source (around line #114):\n112 113 114 115 116 117\ndef call(env)\n_, headers, body = response = @app.call(env)\nif body.respond_to?(:to_path)\ncase type = variation(env)\nExtracted source (around line #102):\n100 101 102 103 104 105\nvary_resource = resource_for_path(path)\nstatus, headers, body = @app.call env\nif add_headers\nheaders = add_headers.merge(headers)\nExtracted source (around line #535):\n533 534 535 536 537 538\ndef call(env)\nreq = build_request env\napp.call req.env\nend\n# Defines additional Rack env configuration that is added on each call.\nExtracted source (around line #76):\n74 75 76 77 78 79\nenv[PATH_INFO] = rest\nreturn app.call(env)\nend\n[404, { CONTENT_TYPE => \"text/plain\", \"x-cascade\" => \"pass\" }, [\"Not Found: \#{path}\"]]\nExtracted source (around line #60):\n58 59 60 61 62 63\nis_host_known = @known_hosts.include? http_host\n@mapping.each do |host, location, match, app|\nunless casecmp?(http_host, host) \\\n|| casecmp?(server_name, host) \\\n|| (!host && is_same_server) \\\nExtracted source (around line #60):\n58 59 60 61 62 63\nis_host_known = @known_hosts.include? http_host\n@mapping.each do |host, location, match, app|\nunless casecmp?(http_host, host) \\\n|| casecmp?(server_name, host) \\\n|| (!host && is_same_server) \\\nExtracted source (around line #277):\n275 276 277 278 279 280\n# every time it is called, so it should not be used if performance is important.\ndef call(env)\nto_app.call(env)\nend\nprivate\nExtracted source (around line #360):\n358 359 360 361 362 363\nenv['HTTP_COOKIE'] ||= cookie_jar.for(uri)\n@last_request = Rack::Request.new(env)\nstatus, headers, body = @app.call(env).to_a\n@last_response = MockResponse.new(status, headers, body, env['rack.errors'].flush)\nclose_body(body)\nExtracted source (around line #163):\n161 162 163 164 165 166\nuri = parse_uri(uri, env)\nenv = env_for(uri, env.merge(method: verb.to_s.upcase, params: params))\nprocess_request(uri, env, &block)\nend\n# Set a header to be included on all subsequent requests through the\nExtracted source (around line #112):\n110 111 112 113 114 115\nclass_eval(<<-END, __FILE__, __LINE__+1)\ndef \#{method_name}(uri, params = {}, env = {}, &block)\ncustom_request('\#{method_name.upcase}', uri, params, env, &block)\nend\nEND\nend\nExtracted source (around line #138):\n136 137 138 139 140 141\nhash.each do |methods, accessor|\nunless defined?(methods.each)\ndef_instance_delegator(accessor, methods)\nelse\nmethods.each {|method| def_instance_delegator(accessor, method)}\nend\nExtracted source (around line #81):\n79 80 81 82 83 84\nreset_cache!\n@new_visit_request = false\nsend(method, new_uri.to_s, attributes, env.merge(options[:headers] || {}))\nend\ndef build_uri(path)\nExtracted source (around line #56):\n54 55 56 57 58 59\ndef process_and_follow_redirects(method, path, attributes = {}, env = {})\n@current_fragment = build_uri(path).fragment\nprocess(method, path, attributes, env)\nreturn unless driver.follow_redirects?\ndriver.redirect_limit.times do\nExtracted source (around line #40):\n38 39 40 41 42 43\nenv = { 'HTTP_REFERER' => referer_url }\nenv['CONTENT_TYPE'] = content_type if content_type\nprocess_and_follow_redirects(\nmethod,\nuri.to_s,\nattributes,\nExtracted source (around line #57):\n55 56 57 58 59 60\naction = button&.[]('formaction') || native['action']\nmethod = button&.[]('formmethod') || request_method\ndriver.submit(method, action.to_s, params(button), content_type: native['enctype'])\nend\ndef multipart?\nExtracted source (around line #69):\n67 68 69 70 71 72\nelsif submits?\nassociated_form = form\nCapybara::RackTest::Form.new(driver, associated_form).submit(self) if associated_form\nelsif checkable?\nset(!checked?)\nelsif tag_name == 'label'\nExtracted source (around line #131):\n129 130 131 132 133 134\ndef \#{meth_name}(...)\nstale_check\nmethod(:\"unchecked_\#{meth_name}\").call(...)\nend\nMETHOD\nend\nExtracted source (around line #131):\n129 130 131 132 133 134\ndef \#{meth_name}(...)\nstale_check\nmethod(:\"unchecked_\#{meth_name}\").call(...)\nend\nMETHOD\nend\nExtracted source (around line #172):\n170 171 172 173 174 175\ndef click(*keys, **options)\nperform_click_action(keys, **options) do |k, opts|\nbase.click(k, **opts)\nend\nend\nExtracted source (around line #608):\n606 607 608 609 610 611\noptions[:offset] ||= :center if session_options.w3c_click_offset\nsynchronize(wait) { yield keys, options }\nself\nend\nend\nExtracted source (around line #84):\n82 83 84 85 86 87\ntimer = Capybara::Helpers.timer(expire_in: seconds)\nbegin\nyield\nrescue StandardError => e\nsession.raise_server_error!\nraise e unless catch_error?(e, errors)\nExtracted source (around line #608):\n606 607 608 609 610 611\noptions[:offset] ||= :center if session_options.w3c_click_offset\nsynchronize(wait) { yield keys, options }\nself\nend\nend\nExtracted source (around line #171):\n169 170 171 172 173 174\n# @return [Capybara::Node::Element] The element\ndef click(*keys, **options)\nperform_click_action(keys, **options) do |k, opts|\nbase.click(k, **opts)\nend\nend\nExtracted source (around line #26):\n24 25 26 27 28 29\n#\ndef click_link_or_button(locator = nil, **options)\nfind(:link_or_button, locator, **options).click\nend\nalias_method :click_on, :click_link_or_button\nExtracted source (around line #774):\n772 773 774 775 776 777\ndef \#{method}(...)\n@touched = true\ncurrent_scope.\#{method}(...)\nend\nMETHOD\nend\nExtracted source (around line #52):\n50 51 52 53 54 55\nclass_eval <<~METHOD, __FILE__, __LINE__ + 1\ndef \#{method}(...)\npage.method(\"\#{method}\").call(...)\nend\nMETHOD\nend\nExtracted source (around line #52):\n50 51 52 53 54 55\nclass_eval <<~METHOD, __FILE__, __LINE__ + 1\ndef \#{method}(...)\npage.method(\"\#{method}\").call(...)\nend\nMETHOD\nend\nExtracted source (around line #73):\n71 72 73 74 75 76\nclick_on 'Ver Pedidos'\nclick_on 'Derp'\nclick_on 'Enviar para Cozinha'\np '<<<<<<<<<<<<<<<<<<<<'\nexpect(page).not_to have_content 'Não foi possível'\nExtracted source (around line #263):\n261 262 263 264 265 266\nrun_before_example\nRSpec.current_scope = :example\n@example_group_instance.instance_exec(self, &@example_block)\nif pending?\nPending.mark_fixed! self\nExtracted source (around line #263):\n261 262 263 264 265 266\nrun_before_example\nRSpec.current_scope = :example\n@example_group_instance.instance_exec(self, &@example_block)\nif pending?\nPending.mark_fixed! self\nExtracted source (around line #511):\n509 510 511 512 513 514\nsingleton_context_hooks_host = example_group_instance.singleton_class\nsingleton_context_hooks_host.run_before_context_hooks(example_group_instance)\nwith_around_example_hooks { yield }\nensure\nsingleton_context_hooks_host.run_after_context_hooks(example_group_instance)\nend\nExtracted source (around line #468):\n466 467 468 469 470 471\ndef with_around_example_hooks\nRSpec.current_scope = :before_example_hook\nhooks.run(:around, :example, self) { yield }\nrescue Support::AllExceptionsExceptOnesWeMustNotRescue => e\nset_exception(e)\nend\nExtracted source (around line #486):\n484 485 486 487 488 489\nwhen :before then run_example_hooks_for(example_or_group, :before, :reverse_each)\nwhen :after then run_example_hooks_for(example_or_group, :after, :each)\nwhen :around then run_around_example_hooks_for(example_or_group) { yield }\nend\nend\nend\nExtracted source (around line #626):\n624 625 626 627 628 629\nreturn yield if hooks.empty? # exit early to avoid the extra allocation cost of `Example::Procsy`\ninitial_procsy = Example::Procsy.new(example) { yield }\nhooks.inject(initial_procsy) do |procsy, around_hook|\nprocsy.wrap { around_hook.execute_with(example, procsy) }\nend.call\nExtracted source (around line #352):\n350 351 352 353 354 355\ndef call(*args, &block)\n@executed = true\n@proc.call(*args, &block)\nend\nalias run call\nExtracted source (around line #174):\n172 173 174 175 176 177\naround do |example|\nexample.run\noriginal_after_teardown.bind(self).call\nend\nend\nExtracted source (around line #457):\n455 456 457 458 459 460\n# @private\ndef instance_exec(*args, &block)\n@example_group_instance.instance_exec(*args, &block)\nend\nprivate\nExtracted source (around line #457):\n455 456 457 458 459 460\n# @private\ndef instance_exec(*args, &block)\n@example_group_instance.instance_exec(*args, &block)\nend\nprivate\nExtracted source (around line #390):\n388 389 390 391 392 393\nclass AroundHook < Hook\ndef execute_with(example, procsy)\nexample.instance_exec(procsy, &block)\nreturn if procsy.executed?\nPending.mark_skipped!(example,\n\"\#{hook_description} did not execute the example\")\nExtracted source (around line #628):\n626 627 628 629 630 631\ninitial_procsy = Example::Procsy.new(example) { yield }\nhooks.inject(initial_procsy) do |procsy, around_hook|\nprocsy.wrap { around_hook.execute_with(example, procsy) }\nend.call\nend\nExtracted source (around line #352):\n350 351 352 353 354 355\ndef call(*args, &block)\n@executed = true\n@proc.call(*args, &block)\nend\nalias run call\nExtracted source (around line #75):\n73 74 75 76 77 78\ngroup.around do |example|\nbefore_setup\nexample.run\nafter_teardown\nend\nend\nExtracted source (around line #457):\n455 456 457 458 459 460\n# @private\ndef instance_exec(*args, &block)\n@example_group_instance.instance_exec(*args, &block)\nend\nprivate\nExtracted source (around line #457):\n455 456 457 458 459 460\n# @private\ndef instance_exec(*args, &block)\n@example_group_instance.instance_exec(*args, &block)\nend\nprivate\nExtracted source (around line #390):\n388 389 390 391 392 393\nclass AroundHook < Hook\ndef execute_with(example, procsy)\nexample.instance_exec(procsy, &block)\nreturn if procsy.executed?\nPending.mark_skipped!(example,\n\"\#{hook_description} did not execute the example\")\nExtracted source (around line #628):\n626 627 628 629 630 631\ninitial_procsy = Example::Procsy.new(example) { yield }\nhooks.inject(initial_procsy) do |procsy, around_hook|\nprocsy.wrap { around_hook.execute_with(example, procsy) }\nend.call\nend\nExtracted source (around line #352):\n350 351 352 353 354 355\ndef call(*args, &block)\n@executed = true\n@proc.call(*args, &block)\nend\nalias run call\nExtracted source (around line #629):\n627 628 629 630 631 632\nhooks.inject(initial_procsy) do |procsy, around_hook|\nprocsy.wrap { around_hook.execute_with(example, procsy) }\nend.call\nend\nif respond_to?(:singleton_class) && singleton_class.ancestors.include?(singleton_class)\nExtracted source (around line #486):\n484 485 486 487 488 489\nwhen :before then run_example_hooks_for(example_or_group, :before, :reverse_each)\nwhen :after then run_example_hooks_for(example_or_group, :after, :each)\nwhen :around then run_around_example_hooks_for(example_or_group) { yield }\nend\nend\nend\nExtracted source (around line #468):\n466 467 468 469 470 471\ndef with_around_example_hooks\nRSpec.current_scope = :before_example_hook\nhooks.run(:around, :example, self) { yield }\nrescue Support::AllExceptionsExceptOnesWeMustNotRescue => e\nset_exception(e)\nend\nExtracted source (around line #511):\n509 510 511 512 513 514\nsingleton_context_hooks_host = example_group_instance.singleton_class\nsingleton_context_hooks_host.run_before_context_hooks(example_group_instance)\nwith_around_example_hooks { yield }\nensure\nsingleton_context_hooks_host.run_after_context_hooks(example_group_instance)\nend\nExtracted source (around line #259):\n257 258 259 260 261 262\nPending.mark_pending! self, skip\nelsif !RSpec.configuration.dry_run?\nwith_around_and_singleton_context_hooks do\nbegin\nrun_before_example\nRSpec.current_scope = :example\nExtracted source (around line #646):\n644 645 646 647 648 649\ninstance = new(example.inspect_output)\nset_ivars(instance, before_context_ivars)\nsucceeded = example.run(instance, reporter)\nif !succeeded && reporter.fail_fast_limit_met?\nRSpec.world.wants_to_quit = true\nend\nExtracted source (around line #642):\n640 641 642 643 644 645\n# @private\ndef self.run_examples(reporter)\nordering_strategy.order(filtered_examples).map do |example|\nnext if RSpec.world.wants_to_quit\ninstance = new(example.inspect_output)\nset_ivars(instance, before_context_ivars)\nExtracted source (around line #642):\n640 641 642 643 644 645\n# @private\ndef self.run_examples(reporter)\nordering_strategy.order(filtered_examples).map do |example|\nnext if RSpec.world.wants_to_quit\ninstance = new(example.inspect_output)\nset_ivars(instance, before_context_ivars)\nExtracted source (around line #607):\n605 606 607 608 609 610\nRSpec.current_scope = :before_context_hook\nrun_before_context_hooks(new('before(:context) hook')) if should_run_context_hooks\nresult_for_this_group = run_examples(reporter)\nresults_for_descendants = ordering_strategy.order(children).map { |child| child.run(reporter) }.all?\nresult_for_this_group && results_for_descendants\nrescue Pending::SkipDeclaredInExample => ex\nExtracted source (around line #121):\n119 120 121 122 123 124\nend\nexample_groups.map { |g| g.run(reporter) }.all?\nend\nend\nExtracted source (around line #121):\n119 120 121 122 123 124\nend\nexample_groups.map { |g| g.run(reporter) }.all?\nend\nend\nExtracted source (around line #121):\n119 120 121 122 123 124\nend\nexample_groups.map { |g| g.run(reporter) }.all?\nend\nend\nExtracted source (around line #2097):\n2095 2096 2097 2098 2099 2100\nRSpec.current_scope = :before_suite_hook\nrun_suite_hooks(\"a `before(:suite)` hook\", @before_suite_hooks)\nyield\nensure\nRSpec.current_scope = :after_suite_hook\nrun_suite_hooks(\"an `after(:suite)` hook\", @after_suite_hooks)\nExtracted source (around line #116):\n114 115 116 117 118 119\nexamples_count = @world.example_count(example_groups)\nexamples_passed = @configuration.reporter.report(examples_count) do |reporter|\n@configuration.with_suite_hooks do\nif examples_count == 0 && @configuration.fail_if_no_examples\nreturn @configuration.failure_exit_code\nend\nExtracted source (around line #74):\n72 73 74 75 76 77\nstart(expected_example_count)\nbegin\nyield self\nensure\nfinish\nend\nExtracted source (around line #115):\n113 114 115 116 117 118\ndef run_specs(example_groups)\nexamples_count = @world.example_count(example_groups)\nexamples_passed = @configuration.reporter.report(examples_count) do |reporter|\n@configuration.with_suite_hooks do\nif examples_count == 0 && @configuration.fail_if_no_examples\nreturn @configuration.failure_exit_code\nExtracted source (around line #89):\n87 88 89 90 91 92\nreturn @configuration.reporter.exit_early(exit_code) if RSpec.world.wants_to_quit\nrun_specs(@world.ordered_example_groups).tap do\npersist_example_statuses\nend\nend\nExtracted source (around line #71):\n69 70 71 72 73 74\noptions.options[:runner].call(options, err, out)\nelse\nnew(options).run(err, out)\nend\nend\nExtracted source (around line #45):\n43 44 45 46 47 48\ndef self.invoke\ndisable_autorun!\nstatus = run(ARGV, $stderr, $stdout).to_i\nexit(status) if status != 0\nend\nExtracted source (around line #4):\n2 3 4\nrequire 'rspec/core'\nRSpec::Core::Runner.invoke\nExtracted source (around line #25):\n23 24 25 26 27 28\nif Gem.respond_to?(:activate_bin_path)\nload Gem.activate_bin_path('rspec-core', 'rspec', version)\nelse\ngem \"rspec-core\", version\nload Gem.bin_path(\"rspec-core\", \"rspec\", version)\nExtracted source (around line #25):\n23 24 25 26 27 28\nif Gem.respond_to?(:activate_bin_path)\nload Gem.activate_bin_path('rspec-core', 'rspec', version)\nelse\ngem \"rspec-core\", version\nload Gem.bin_path(\"rspec-core\", \"rspec\", version)\nExtracted source (around line #22):\n20 21 22 23\neval content, binding, $0, start_line\nelse\neval content, binding, $0\nend\nExtracted source (around line #22):\n20 21 22 23\neval content, binding, $0, start_line\nelse\neval content, binding, $0\nend\nRails.root: /home/cmf/Documents/treinadev/crashcourse/ruby-on-rails-uma-abordagem-com-tdd/projetos/paleva\nApplication Trace | Framework Trace | Full Trace\napp/controllers/orders_controller.rb:30:in `send_to_kitchen'\nRequest\nParameters:\n{\"_method\"=>\"patch\", \"restaurant_id\"=>\"1\", \"id\"=>\"1\"}\nToggle session dump\nsession_id: \"455beaa382aa84bc2ecc3ed26e803aaf\" warden.user.user.key: [[1], \"$2a$04$YlVpIjovhcQ1Mwgoa8yele\"]\nToggle env dump\nORIGINAL_SCRIPT_NAME: \"\" REMOTE_ADDR: \"127.0.0.1\" SERVER_NAME: \"www.example.com\" SERVER_PROTOCOL: \"HTTP/1.0\"\nResponse\nHeaders:\nNone"
     # ./spec/system/orders/user_sends_order_to_kitchen_spec.rb:76:in `block (2 levels) in <top (required)>'

Finished in 0.82542 seconds (files took 1.64 seconds to load)
1 example, 1 failure

Failed examples:

rspec ./spec/system/orders/user_sends_order_to_kitchen_spec.rb:59 # Usuário finaliza pedido e pedido não pode estar vazio

